public class First {
    //실행하는 메소드
	//프로그램이 실행될려면 main이 있어야 합니다.
	//한줄 주석(comment - 보출설명 : 해석안함)
	
	/*
	 여러줄 주석
	 주석은 잘 만들어주는 것도 프로그램을 잘 작성하는 것
	 중의 하나입니다.
	 */
	
	public static void main(String[] args) {
		System.out.println("안녕하세요 반갑습니다.");
	}
}
//============================0122===========================
//프로그램 : Data(저장) 와 Function(기능)의 모임

//class: 관련있는 Data와 Function(method)의 집합 : 모델하우스, 진열품

//object - instance(객체): 클래스를 실제 사용할 수 있도록 메모리
//할당받은 것, 실제 아파트, 실제상품


//Machine <-> Machine Language(기계어 - 2진수) <-> Assemble <-> 
//고급언어
//Compile은 고급언어를 Assemble로 변경해 주는 것입니다
//Assembler가 Assemble 언어로 만들어진 기계어로 번역

//역어셈블 : 어셈블리 언어로 만들어진 것을 원래의 구조로 되돌리는
//것입니다.

//Data(자료)
//1.데이터 분류
// 1)변경 가능 여부에 따른 분류
//  -immutable(변경 불가능한) Data : Literal(언어에서 자료를
//  표현하는 방법 - 10(정수), 'A'(문자A))과 Constant(개발자
//  가 의도적으로 변경 불가능하도록 만든 것 - read only)

//  -mutable(변경 가능한) Data: Variable(변수)

//2)저장하고 있는 데이터 개수에 따른 분류
//  -Scala(1개 데이터) : 데이터 1개만 저장
//  -Vector(n개 데이터) : 0개 이상의 데이터를 저장 - 분석의 대상

//3)저장하고 있는 데이터 종류에 따른 분류
//  -Value: 값을 저장
//  -reference(참조): 데이터를 읽어올 수 있는 참조를 저장

//2.변수를 만드는 방법
//자료형 변수명;

//3.변수의 데이터를 대입
//변수명 = 데이터;

//4.저장된 데이터를 읽어오는 방법
//변수명(변수를 만들 때와 =의 왼쪽에 있을 때를 제외하고는 변수에
//저장된 데이터를 의미합니다.)

//5.Data Type(자료형)
//데이터를 저장하기 위해서 얼마만큼의 메모리를 할당하고 어떤
//방법으로 저장할 것인지의 문제

//6.java에서의 자료형 분류
//1)primitive type(기본형 - value형): 데이터 자체를 저장하는 것

//2)reference type(참조형): 데이터의 참조를 기억하는 것

//7.java에서 leteral 작성
//1)boolean(논리 - 참, 거짓): true또는 false

//2)정수: 10진수(절대값 21억정도까지), 10진수L(long형 정수)
//  0x숫자(16진수 - 참조를 표현하기 위해서 사용)
//  0숫자(8진수 - UNIX나 LINUX에서 권한 부여 할 때 많이 이용)

//3)실수 : 정수.소수(double형 실수)
//         정수.소수f(float형 실수)

//4)문자(1글자): '글자' 또는 0-65535 사이의 숫자

//5)문자열(0개 이상의 글자 집합): "글자들"

//null - 참조형literal : 가리키는게 없음
 
//8.java의 primitive type
//기본형이라고 하는데 데이터 자체를 저장하는 자료형
//1)숫자
//byte : 1byte를 할당  -128 ~ 127
//       숫자를 저장하는 목적으로는 잘 사용안하고 통신이나 파일에
//       데이터를 읽고 쓸 때 많이 사용
//short: 2byte를 할당 -32768 ~ 32767

//int: 4byte를 할당 절대값으로 21억 정도까지 저장
//     정수의 기본형(정수를 가지고 계산할 때 사용)
//     가장 많이 사용하는 정수

//long: 8byte를 할당 절대값 21억 * 42억정도 까지 저장
//      숫자를 쓸 때는 뒤에 L을 붙여서 표기

//fioat: 4byte를 할당 10의 38승까지 저장하고 정밀도는 소수7째 자리까지
//       숫자를 쓸 때는 뒤에 f를 붙입니다.

//double: 8byte를 할당 10의 308승까지 저장하고 정밀도는 소수15번째
//자리까지 이고 실수의 기본형

//char: 12byte로 정수를 저장할 수도 있고 문자를 저장할 숭 있습니다.
//      char는 출력할 때 코드에 해당하는 문자를 출력하는 것입니다.
//2)논리
//boolean: 1byte, ture나 false를 저장

//3)숫자 자료형의 경우 큰자료형의 데이터를 작은 자료형의 변수에
//대입이 불가능합니다.

//byte < short  < char < int < long < float < double

//4)변수를 만들 때 바로 값을 대입할 수도 있습니다.
//자료형 변수명 = 데이터;

//5)동일한 자료형의 변수를 여러개 만들때는 한꺼번에 생성해도 됩니다.
//자료형 변수명1, 변수명2;

//형 변환(Type Casting)
//데이터의 자료형이 변경되는 것

//1.자동 형 변환
//데이터의 자료형이 자동으로 변환되는 경우
//1)작은 자료형의 데이터를 큰 자료형의 변수에 대입하는 경우에 작은
//자료형의 데이터가 큰 자료형의 데이터로 변경되서 대입됩니다.

//double d = 10; //10이 10.0을 변경되서 대입됩니다.

//2)정수끼리 연산은 int보다 작은경울 int로 변경해서 연산합니다.
//연산 - 계산작업
//byte b1 = 10;
//byte b2 = 20;
//byte b3 = b1 + b2; //에러가 발생합니다
//byte끼리 덧셈을 하면 int보다 작기 때문에 int로 변경해서 작업을
//합니다.

//3)서로 다른 자료형의 데이터 끼리 산술 연산을 하면 큰자료형의
//데이터로 변경해서 연산합니다.

//10 + 13.7 = 10.0 + 13.7로 변경해서 수행

//2.강제 형 변환
//데이터의 자료형을 강제로 변환하는 것
//기본형의 경우는 숫자끼리만 가능
//참조형은 상속관계인 경우만 가능

//1)작은 자료형을 큰 크기의 자료형으로 변경하는 경우는 원하는 연산의
//결과를 얻기 위해서 입니다.

//2)큰 자료형을 작은 자료형으로 변경하는 경우는 연산의 결과가 잘못된
//경우를 방지하기 위해서 입니다.

//실수를 정수형으로 변경하게 소수는 버려지게 됩니다.
//같은 정수형인데 큰 자요형의 데이터를 작은 자료형의 데이터로 변경하다
//보면 Overflow나 Underflow가 발생할 수 있습니다.

//3)하는 형식
//(자료형)데이터: 데이터가 자료형으로 변경됩니다.


//컴퓨터는 숫자를 이진수로 저장

//실수를 이진수로 변경할 때는 2를 곱하면서 정수부분만 순서대로 표기

//실수를 이진수를 변경할 때는 2를 곱하면서 정수부분만 순서대로 표기
//소수부분이 없어질 때 까지 반복

//0.6 * 2 = 1.2
//0.2 * 2 = 0.4
//0.4 * 2 = 0.8
//0.8 * 2 = 1.6

//실수는 이진수로 표현할 수 없는 숫자가 있을 수 있습니다.
//시룻를 가지고 여러번 계산작업을 해야 하는 경우게는 정수로 변경해서
//작업한 후 나누기를 해서 실수로 변경하는 것이 좋습니다.
//========================0123=============================
//문자(String)
//문자열 Literal은 ""안에 기재
//자료형은 String 클래스

//변수를 선언하고 값을 대입할 때는
//String 변수명 = "문자열";

//제어문자(White Space)
//\로 시작하고 하나의 영문자가 결합된 문자
//\n(줄바꿈,) \t(탭), \\(역슬래시), \'(작은 따옴표), \"(큰 따옴표) 등


//Operator(연산자)
//산술연산(숫자 연산)이나 논리연산(참 거짓 연산)을 수행해주는
//부호나 명령어

//a = 10; //10을 a에 대입한다.

//1.최우선 연산자

//1) ( ) : 연산의 우선순위를 변경하기 위해서 사용
//2) [ ] : 배열을 생성하거나 배열의 요소를 접근할 때 사용하는 연산자

//2.산술 연산자(덧셈, 뺄셈, 나눗셈..)
//% : 나머지를 구해주는 연산자

//*, /: 곱셈과 나눗셈

//+, -: 덧셈과 뺄셈

//동일한 자료형끼리 산술연산을 하면 동일 자료형으로 결과가
//리턴됩니다.
//서로 다른 자료형끼리 산술연산을 하면 더 큰 자료형으로 형변환해서
//수행됩니다.
//int보다 작은 정수끼리 연산을 하면 int로 변경해서 연산을 수행합니다.

//%는 정수 데이터(변수와 상수)끼리만 가능합니다.

//%는 주기적인 작업을 만들 때 이용을 할 수 있습니다.
//한자리 입역오류를 확인할 때도 %를 이용(주민등록번호 유효성,
//카드번호, 계좌번호 등)

//3.증감 연산자(++, --)
//정수 변수에만 사용 가능한 연산자

//변수의 값을 1증가(++) 시키거나 감소(--)시킵니다.

//++나 --가 변수의 앞에 놓이면 변수의 값을 증감하고 명령에 
//사용합니다.
//변수의 뒤에 놓이면 명령의 사용하고 값을 증감합니다.

//int a = 10;
//a++;
//System.out.println(a); //11이 출력됩니다.
//a--;
//System.out.println(a); //10이 출력됩니다.
//System.out.println(++a); //10이 출력되고 a가 11이됩니다.
//System.out.println(a++); //a가 12가 되고 12를 출력

//a = a + 1; //a의 갑을 1증가시키는 문장

//조건 논리 연산자
//boolean 데이터끼리 연산해서 결과를 boolean으로 리턴하는 연산자

//&&(and): 둘다 true일 때만 true 그 이외의 경우는 false
//||(or): 둘다 false일 때만 false 그 이외의 경우는 true
//!(not): true이면 false, false이면 true

//and는 둘 다 true인 경우만 true
//앞쪽의 데이터가 false이면 뒤쪽 데이터를 확인하지 않고 false

//or는 둘 다 false일 때만 false
//앞쪽의 데이터가 true이면 뒤 쪽 데이터를 확인하지 않고true

//삼항 연산자

//조건 ? 참일 때 내용 : 거짓일 때 내용
//======================0124============================
//제어문

//대다수 프로그래밍 언어의 흐름은 왼쪽에서 오른쪽, 위에서 아래로 진행
//제어문은 일반적인 제어흐름을 따르지 않도록 해주는 명령어

//제어문의 종류

//1.분기(jump)
//1)if : 조건분기(true, false)
//2)Switch : 값에 대한 분기(정수, String)
//3)go to (무조건 분기) : 사용못함

//2.반복(Loop, Iteration)
//1)for - 데이터의 모임, 순회
//2)while - 조건이 false일때 까지 수행
//3)do while - 조건이 false일때 까지 수행

//3.기타제어문
//1)break : 반복문이나 Switch 중단
//2)continue : 반복문에서 첫줄로 이동
//3)return : 메소드 수행 종료

//if(조건분기)Condition=>true or false

//if(Condition){
//Condition이 ture일때 수행내용
//}
//else if(Condition) {
//Condition이 true일때 수행내용
//}
//else {
//앞의 Condition이 전부 false일때 수행내용
//}



//switch: 값(정수, 문자열)에 의한 분기

//switch(정수나 문자열 데이터){
//case 값1:
//     값1일 때 수행할 내용;
//    break;
//case 값2:
//     값2일 때 수행할 내용;
//    break;
//case 값3:
//     값3일 때 수행할 내용
//    break;

//default:
//위의 모든 값과 일치하지 안을때 수행할 내용;
//     braek;
//}

//default는 생략 가능
//case의 개수는 제한 없음
//break를 생략하면 break를 만날 때까지 모든 문장을 수행


//switch문은 if문으로 변경이 가능합니다.
//if문은 switch문으로 만들지 못할 수 도 있습니다.
//switch는 정수와 문자열 데이터만 사용이 가능


//while

//while(boolean 데이터){
//    반복할 내용;
//}
//boolean 데이터가 false가 될 때까지 {}안의 내용을 반복

//do-while
//do {
//  반복할 내용;
//}while(boolean 데이터);

//boolean 데이터가 false가 될 때 까지 {}안에 내용을 반복
//while은 boolean데이터가 먼저 나오기 때문에 {}안의 내용을 한번도
//수행하지 않을 수도 있지만 do-while은 boolean데이터가 뒤에 있기
//때문에 무조건 {}안의 내용은 한번은 수행을 합니다.


//for(처음 한번만 할 내용; 조건; 두번째부터 수행할 내용){
//             반복할 내용
//}

//제어문 안에서 변수생성 가능
//단 제어문 안에서 만든 변수는 제어문 안에서만 사용 가능
//제어문안에 제어문을 사용할 수 있음.

//if와 반복문에서 수행할 내용이 한줄이면 {}를 생략해도 됩니다.
//가독성을 위하여 생략하지 않는것을 추천합니다.~

//break
//switch와 반복문에 사용하는 제어문으로 switch나 반복문의
//수행을 종료하는 명령어

//continue
//반복문에서 사용하는 제어문으로 반복문의 시작부분으로 이동하는 명령어
//while 일 때는 조건부분으로 이동하고 do-while은 {}의 시작 부분으로
//for일 때는 (;;요기)로 이동합니다.

//반복문에 사용될 때는 보통 if와 같이 사용되서 어떤 조건을 만족하면
//반복문의 수행을 종료하는 용도로 사용합니다.


//switch(교번 - toggle) 처리 : 번갈아 가면서 수행
//========================0125===============================
//Array(배열)
//동일한 자료형 데이터들의 연속된 집합
//Java에서는 Heap 메모리에 생성합니다.

//배열이 없는 경우 여러개의 데이터를 사용할려면 여러 개의 이름이
//필요합니다
//배열은하나의 이름으로 여러개의 데이터를 관리할 수 있습니다

//배열을 만들 때는 되도록이면 비교 가능한 데이터들로만 구성해야 합니다.

//1.배열을 생성

//1)생성한 후에 값을 대입
//데이터1개의 자료형[] 배열이름 = new 자료형[개수];
////개수만큼의 데이터를 저장할 수 있는 배열이 생성되는데 모든값은0,
//0.0, false, null로 채워집니다.

//2)초기 데이토를 가지고 생성
//데이터1개의 자료형[] 배열이름 = {데이터 나열};
////나열된 데이터개수 만큼 데이터를 저장한 배열이 생성

//2.배열의 데이터 사용
//1)1개 데이터를 지정: 배열이름[인덱스]
//인덱스는 0부터 데이터개수 -1만큼 사용 가능

//2)배열이름.length: 데이터 개수를 리턴

//3)배열의 데이터 전체 순회
//for(1개를 저장할 수 있는 변수: 배열이름){
//         내용
//}
//배열의 데이터를 변수에 순서대로 하나씩 대입하고 {}안에 내용수행
//이 문법을 Fast Enumeration(빠른 열거) 이라고 합니다.

//3.MVC Pattern
//프로그램은 데이터를 만들어내는 부분 (처리 - Model)과 화면에
//출력하는 부분(View)그리고 2개를 연결해주는 부분 (Controller)로
//나누어서 작성하는 패턴인데 이렇게 나누어서 작성을 하면 코드를 읽기도
//편하고 나누어서 작업하기 편리합니다.
//이 때 Model에 변화가 생기더라고 View에 영향을 주지 않고 출력하도록
//프로그램을 만들어 주어야 합니다.

//int [] intAr = {10, 30, 50, 20, 40};

//intAr : 배열의 데이터 시작 주소

//[0] - 10
//    - 30
//    - 50
//    - 20
//    - 40
//for(int i=0; i<intAr.length; i++){
//    System.out.println(intAr[i])
//}

//intAr[0]: intAr이 저장하고 있는 주소에 가서 0번째 데이터를 찾아옵니다.
//intAr[0]: intAr이 저장하고 있는 주소에 가서 2번째 데이터를 찾아옵니다.

//for(int temp : intAr){
//   System.out.println(temp);
//}

//배열의 데이터를 처음부터 마지막 요소까지 전부 접근하는 경우에는
//일반 반복문을 사용하는 것보다는 빠른 열거를 사용하는 것이 좋습니다.

//============================0128=============================
//구조적 프로그래밍 언어(Structured Programming Language):
//프로그램을 블럭 단위로 나누어서 프로그래밍 언어 - 기계어 와 어셈블리어
//를 제외한 거의 모든 프로그래밍 언어가 구조적 프로그래밍 언어입니다.

//절차적 프로그래밍 언어: 프로그램이 순서대로 작성되어야 하는 언어 -
//C언어가 대표적으로 프로그래밍 언어 - 변수를 선언하느 영역이 먼저나오고
//처리하는 코드가 나와야 합니다.

//C언어는 이 구조가 안됩니다.
//int a;
//a = 10;
//int b;

//객체 지향 언어: 클래스 단위로 묶어서 프로그래밍
//- C#, Java
//C++, Python, Swift, Kotlin, Rudy...(객체 지향 언어이면서 함수형
//프로그래밍 언어 - C언어처럼 함수가 별도로 존재할 수 있는 언어)

//스크립트 언어: 줄 단위로 실행하는 언어 - Python, Swift, Kotlin,
//Javascript..


//자료구조와 알고리즘은 필수
//디자인 패턴은 보통 객체 지향 언어를 하는 사람들이 공부
//C언어만 하는 경우는 디자인패턴을 중요하게 생각하지 않음

//클래스(Class): 동일한 목적을 위해 모인 변수와 메소드의 집합
//사용자가 만든 사용자 정의 자료형
//클래스 자체를 사용하기도 하지만 클래스를 이용해서
//인스턴스를 만든 후 인스턴스를 사용

//인스턴스(Instance): 클래스를 기반으로 해서 heap 메모리를 할당받은
//것으로 실제 사용되는 것

//인스턴스 생성 - 생성자는 클래스 이름과 동일
//클래스이름 변수명 = new 생성자();


//변수(Variable)
//1.지역 변수(Local Variable)
//메소드 안에서 생성한 변수
//메소드(){ }
//자동 초기화가 되지 않고 처음 값을 대입했을때 메모리 할당을 받아서
//생성
//메소드 수행이 시작될 때 생성되고 메소드 수행이 종료되면 자동
//소멸됩니다.
//변수를 선언할 때 final을 붙이면 값을 변경할 수 없는변수로
//생성됩니다.

//2.인스턴스 변수(Instance Variable)
//클래스 안에 static이라는 키위드 없이 생성된 변수
//이 변수는 인스턴스를 통해서만 접근이 가능
//인스턴스.변수명으로 접근
//클래스 내부의 메소드에서는 중복된 이름이 없다면 인스턴스.을
//생략하고 변수명으로 접근이 가능
//객체가 할당받아서 사용하고 객체의 사용이 종료되면 소멸됩니다.

//3.static 변수(Static Varible)
//클래스 안에서 static 이라는 키워드와 함께 생성된 변수
//이 변수는 static 영역에 1개만 생성
//외부에선느 클래스이름으로 접근이 가능하고 인스턴스를 이용해서도
//접근이 가능합니다.
//만드는 목적은 데이터의 공유

//4.final
//변수 앞에 final을 붙이면 읽기 전용이 됩니다.
//final은 생성할 때 바로 초기화를 해야 합니다.

//5.접근 지정자
//public: 클래스 내부에서 사용 가능하고 외부에서도 사용이 가능

//private: 클래스 내부에서만 사용 가능


//6.static initializer
//클래스 안에 static {} 을 만들어서 코드를 작성하면 클래스를 처음
//로드할 때 한 번만 호출해서 수행합니다.

//{}안에서 인스턴스 변수 사용은 안됩니다.

//인스턴스 변수는 인스턴스가 만들어져야 사용할 수 있는데 static {}
//은 인스턴스를 만들기 전에 1번만 호출됩니다.


//Method
//독자적인 메모리 영역을 실행되는 코드의 모임
//자주 사용하는 코드를 묶어서 하나의 이름으로 만들어 둔 것
//크래스 안에 만들면 Method라고 하고 클래스 외부에 만들면
//Function이라고 합니다.

//1.메소드 생성
//[접근지정자] [메소드 특성] 리턴타입 메소드이름([매개변수 낭ㄹ]){
//   메소드 내용
//   return [데이터]
//}

//2.메소드 호출
//클래스 내부에서는 메소드이름([매개변수 값 나열])
//클래스 외부에서는 인스턴스이름.매소드이름([매개변수 값 나열])
//클래스 외부에서는 클래스이름.메소드이름([매개변수 값 나열])


//Hello World를 5번 출력 코드
//for(int=0; i<5; i=i+5){
//    System.ot.println("Hello World");
//}

//리턴이 없을 때는 결과형은 void
//public void disp(){
//   for(int=0; i<5; i=i+5){
//   System.ot.println("Hello World");
//}

//3.매개변수(argument)
//메소드를 호출할 때 대입해야 하는 데이터
//없을 수도 있고 여러 개일 수도 있습니다.
//메소드를 만들 때 매개변수를 만들면 호출 할 때 반드시 매개변수를 
//대입해야 합니다
//동일한 클래스에 메소드 이름은 같고 매개변수의 자료형이나 개수를
//다르게 하는 함수가 존재할 수 있는데 이 경우리 Method Overloading
//이라고 합니다.
//===========================0129========================
//매개변수 전달방법
//1.Call by Value : 값에 의한 전달
//매개변수가 기본형
//메소드 내부에서 전달된 원본데이터를 변경할 수 없다.

//2.Call by Reference : 참조에 의한 전달
//매개변수가 참조형
//메소드 내부에서 전달된 원본 데이터를 변경할 수 있다.

//return
//return: 메소드의 수행을 종료하고 호출한 곳으로  돌아가는 예약어
//return type(결과형): 메소드의 수행이 종료되고 호출한 곳에 넘겨주는
//데이터의 자료형, 없으면 void


//static 메소드
//메소드의 자료형 앞에 static이 붙은 메소드
//클래스와 인스턴스 모두 호출할 수 있는 메소드
//Static이 없는 메소드는 반드시 인스턴스가 호출해야 합니다.
//메소드 내부에서 인스턴스 변수를 호출하는 것은 안됩니다.
//인스턴수 변수를 사용하지 않는 메소드는 되도록이면 static 메소드로
//만드는 것이 좋습니다.

//SCOPE의 법칙
//동일한 이름의 변수가 존재하는 경우(지역변수 <-> 인스턴스 변수 또는 static변수)
//가까이에서 만든 변수를 먼저 찾아갑니다.
//이름만 사용하게 되면 지역에서 먼저 찾고 없으면 인스턴스 변수나
//static변수에서 확인하게 됩니다.
//메소드 내에서 지역변수와 인스턴스 변수 또는 static변수의 이름이
//같을 때 인스턴스 변수나 static 변수를 호출하고자 하면 this.을 앞에
//붙여서 호출해야 합니다.
//this는 메소드 내에서 인스턴스 자신을 가리키는 포인터입니다.


//접근자 메소드(getter & setter)
//객체 지향 프로그래밍에서는 인스턴스 변수는 private으로 해서
//인스턴스가 직접 접근하지 못하도록 하고 접근다 메소드를 이용해서
//접근하도록 하는 것을 권장합니다.
//getter: 변수의 값을 리턴하는 메소드
//        이름은 get변수명 - 변수명의 첫글자는 대문자
//        return type은 변수의 자료형
//        매개변수는 없습니다.
//        내용은 변수의 값을 리턴합니다.
//        예외적으로 변수의 자효형이 boolean이면 get 대신에 is를
//        붙입니다.

//setter: 변수의 값을 변경하는 메소드
//        이름은 set변수명 - 변수명의 첫글자는 대문자
//        return type은 void
//        매개변수는 변수의 자료형과 동일한 자료형으로 1개
//        내용은 매개변수로 받은 데이터를 인스턴스 변수에 대입

//Constructor(생성자)
//Instance(객체)를 만들 때 호출하는 메소드
//생성자를 만들지 않으면 매개변수가 없는 생성자가 제공되고 생성자를
//직접 만들면 제공되는 생성자는 소멸됩니다.

//1.생성자를 만들 때의 규칙
//생성자의 이름은 클래스 이름과 동일해야 합니다.
//return type은 없습니다(void가 아닙니다.)
//생성자는 overloading이 가능합니다(overloading: 메소드의 이름은
//같고 매개변수의 개수나 자료형이 다른 경우)

//생성자 호출은 new 생성자이름(매개변수)
//생성자를 호출하면 생성자에 해당하는 클래스의 인스턴스를 heap에
//생성하고 그 참조를 리턴합니다.

//인스턴스 생성: new 생성자이름()
//보통의 경우는 클래스이름 변수명 = new 생성자이름(); 의 형식으로
//인스턴스를 생성합니다.

//3.클래스의 document를 읽을 때 생성자를 잘 확인해야 합니다.
//생성자의 종류만큼 인스턴스를 만드는 방법이 달라지게 됩니다.
//생성자가 보이지 않으면 인스턴스 생성할 수 없거나 다른 방법을
//사용해야 합니다.

//package
//유사한 역할을 하는 java class의 모임입니다.
//java에서는 package단위로 배포가 이루어집니다.
//jar 파일로 압축해서 배포합니다. 압축된 jar 파일을 자바는 풀어서
//해석을 하게 됩니다.

//import
//java에서는 package 이름을 생략하고 클래스를 사용하기 위해서 설정
//java.lang패키지는 기본적으로 import가 되어있습니다.
//java.util.Scanner라는 클래스를 사용하고자 하는 경우 import를
//이용하지 않으면 java.util.Scanner라고 입력해야 합니다.

//java.util.*이라고 import하게 되면 java.util 패키지의 모든 클래스를
//클래스 이름만으로 사용이 가능합니다.

//java.util.Scanner라고 import 하게되면 java.util 패키지의 Scanner
//클래스만 줄려쓸 수 있게 됩니다.

//Eclipse에서 자동 import 해주는 단축키는 ctrl + shift + o

//java의 주요 패키지
//java로 시작하면 java가 만들어질 때 부터 있던 패키지
//javax로 시작하면 나중에 추가된 패키지
//그 이외의 단어로 시작하면 oracle(예전 sun)에서 만든 패키지가 아님

//java.lang: java의 기본 패키지로 Wrapper 클래스들과 Thread 클래스

//java.util: 자료구조 클래스와Random 그리고 날짜와 관련된 클래스,
//Scanner 클래스가 존재하는 패키지

//java.io와 java.nio 패키지: 입출력 관련 클래스 패키지(파일에
//기록하고 읽고 네크워크를 통해서 전송하고 읽는 클래스)

//java.net: 네트워크 관련 패키지

//java.sql, javax.sql: 데이터베이스 관련 패키지

//java.awt, javax.swing: 윈도우 프로그래밍 관련 패키지
//=========================0130===================================
//java는 단일상속(하나의 클래스오부터 상속)만 지원
//extends 구문이 생략되면 java.lang.Object 클래스로부터 상속받은
//것으로 간주

//super 와 super()
//1.super: 상위 클래스에서 찾을 때 사용하는 예약어
//클래스 안에서 어떤 이름을 사용할 때 아무것도 붙이지 않으면 자신의
//메소드안에서 찾고 없으면 자신의 클래스에서 찾고 그래도 없으면 상위
//클래스에서 찾습니다.
//클래스 안에서 this. 을 붙이면 자신의 메소드 안에서는 찾지 않고
//자신의 클래스에서 먼저 찾고 없으면 상위 클래서에서 찾습니다.
//super.을 붙이면 상위 클래스에서만 찾습니다.

//2.super()
//상위 클래스의 생성자를 직접 호출할 때 사용하는 구문
//생성자에서만 사용할 수 있고 맨 윗줄에 한 번만 나와야 합니다.
//원래 하위 클래스의 생성자에는 눈에 보이지는 않지만 상위 클래스의
//메개변수가 없는 생성자를 호출하는 super()구문이 있다고 봐야 합니다.
//상위 클래스에 매개변수가 없는 생성자(default constructor)가 없으면
//하위 클래스의  생성자레서 직접 상위 클래스의 생성자를 호출해 주어야
//합니다.

//3.method overriding
//상위 클래스와 하위 클래스에 동일한 원형(이름과 매개변수의 개수 및 
//자료형)의 메소드가 존재하는 경우
//overloading: 이름은 같고 매개변수나 개수나 자료형이 다른 경우
//이런 경우 하위 클래스에서 상위 클래스의 메소드를 호출할 때 
//super.을 붙여서 호출합니다.

//4.참조형 변수 사이의 대입 - 객체 지향 언어에서 많이 중요
//상위 클래스 타입으로 만들어진 참조형 변수에 하위 클래스 타입으로
//만들어진 인스턴스의 참조를 형변환 없이 대입할 수 있습니다.
//하위 클래스 타입으로 만들어진 참조형 변수에 상위 클래스 타입으로
//만들어진 인스턴스의 탐조는 강제 형 변환을 해야만 대입할 수 있습니다.
//단 이때 인스턴스가 원해 하위 클래스 타입으로 만들어진 경우에만
//실행은 가능합니다.(책임은 프로그래머가 져야한다.)
//멤버를 호출할 때는 변수를 만들 때 사용한 타입의 것을 호출하지만
//오버라이딩 된 메소드 만은 인스턴스를 만들 때 사용한 생성자를 보고
//호출합니다.
//===========================0131==========================================

//상속
//1.제공되는 클래스의 기능 확장(Extension: subclassing)
//2.공통된 요소가 있을 때 하나로 묶기 위해서
//3.다형성(polymorphism)을 구현하기 위해서
//하나의 메세지에 대하여 다르게 반응합니다.
//동일한 코득 상황에 따라 다른작업수행


//abstract(추상)
//1.abstract 클래스: 인스턴스 생성을 못하고 상속을 통해서만 사용하는클래스
//class 앞에 abstract

//final
//1.final 변수: 값을 변경할 수 없음
//2.final 메소드: Overriding을 못함
//3.final 클래스: 상속 못함

//상속하는 이유
//1.기존에 존재하는 클래스으 기능이 부족해서 기능을 확장하고자 할 때
//->subclassing 이라고 하는 경우가 많습니다.

//2.여러 개의 클래스에 공통된 내용이 있어서 묶어주기 위해서

//3.polymorphism(다형성)을 구현하기 위해서